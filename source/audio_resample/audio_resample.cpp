#ifdef __cplusplus
extern "C"
#endif
{
#include "libavutil/audio_fifo.h"
#include "libavcodec/avcodec.h"
#include "libavformat/avformat.h"
#include "libswscale/swscale.h"
#include "libavutil/opt.h"
#include "libavutil/channel_layout.h"
#include "libavutil/samplefmt.h"
#include "libswresample/swresample.h"
#ifdef __cplusplus
};
#endif
#include "audio_resample.h"
#include <thread>
#include <memory>
#include <functional>



#define ALOGD(fmt, ...)   av_log(nullptr, AV_LOG_DEBUG, "jie=[%s:%d]" fmt "\n", __FUNCTION__, __LINE__, ##__VA_ARGS__)
#define ALOGI(fmt, ...)   av_log(nullptr, AV_LOG_INFO, "jie=[%s:%d]" fmt "\n", __FUNCTION__, __LINE__, ##__VA_ARGS__)
#define ALOGW(fmt, ...)   av_log(nullptr, AV_LOG_WARNING, "jie=[%s:%d]" fmt "\n", __FUNCTION__, __LINE__, ##__VA_ARGS__)
#define ALOGE(fmt, ...)   av_log(nullptr, AV_LOG_ERROR, "jie=[%s:%d]" fmt "\n", __FUNCTION__, __LINE__, ##__VA_ARGS__)


std::function<void(AVAudioFifo*)> FiFo_DeleteFun = [](AVAudioFifo *ptr) {
    if (ptr) {
        av_audio_fifo_free(ptr);
    }
};

std::function<void(SwrContext*)> Swr_DeleteFun = [](SwrContext *ptr) {
    if (ptr) {
        swr_free(&ptr);
    }
};

std::function<void(AVFrame*)> AVFrame_DeleteFun = [](AVFrame *ptr) {
    if (ptr) {
        av_frame_free(&ptr);
    }
};


class AudioFiFO {
public:
    AudioFiFO():
        m_audioFifo(nullptr, FiFo_DeleteFun)
    {

    }
    ~AudioFiFO()
    {
        m_audioFifo.reset();
    }

    int initFiFO(int32_t channels, enum AVSampleFormat format) {
        int result = 0;
        m_channels = channels;
        m_format = format;

        m_audioFifo.reset(av_audio_fifo_alloc(m_format, m_channels, 1));
        if (!m_audioFifo) {
            ALOGE("Could not allocate FIFO");
            result = -1;
            return result;
        }
        return result;
    }

    int getFifoSize() {
        return av_audio_fifo_size(m_audioFifo.get());
    }

    void refreshFifo() {
        return av_audio_fifo_reset(m_audioFifo.get());
    }

    int pushAudioData(uint8_t **input_samples, const int frame_size) {
        int result = 0;
        if ((result = av_audio_fifo_realloc(m_audioFifo.get(), getFifoSize() + frame_size)) < 0) {
            ALOGE("Could not reallocate FIFO");
            return result;
        }

        if (av_audio_fifo_write(m_audioFifo.get(), (void**)input_samples, frame_size) < frame_size) {
            ALOGE("Could not write data to FIFO");
            return -1;
        }
    }

    int popAudioData(uint8_t **output_samples, const int nb_samples) {
        int fifo_size = getFifoSize();
        fifo_size = fifo_size < nb_samples ? fifo_size : nb_samples;
        int result = av_audio_fifo_read(m_audioFifo.get(), (void**)output_samples, fifo_size);
        if (result < fifo_size) {
            ALOGE("av_audio_fifo_read  error  %d < %d", result, fifo_size);
        }
        return result;
    }

private:
    std::unique_ptr<AVAudioFifo, decltype(FiFo_DeleteFun)> m_audioFifo;
    int32_t m_channels;
    enum AVSampleFormat m_format;

};



class AudioResample {
public:
    AudioResample() :
        m_swr_ctx(nullptr, Swr_DeleteFun),
        m_audiofifo(new AudioFiFO()),
        m_temp_buffer(nullptr, AVFrame_DeleteFun) {

    }

    ~AudioResample() {
        m_swr_ctx.reset();
        m_audiofifo.reset();
    }

    void setInputAudioParm(int32_t sample_rate, int32_t channels, enum AVSampleFormat format) {
        m_src_samplerate = sample_rate;
        m_src_channels = channels;
        m_src_format = format;
    }

    void setOutputAudioParm(int32_t sample_rate, int32_t channels, enum AVSampleFormat format) {
        m_dst_samplerate = sample_rate;
        m_dst_channels = channels;
        m_dst_format = format;
    }

    int createEngine() {
        int result = 0;
        m_swr_ctx.reset(swr_alloc());
        if (m_swr_ctx == nullptr) {
            ALOGE("Failed to initialize the resampling context");
            result = -1;
            goto end;
        }
        /* set options */
        av_opt_set_int(m_swr_ctx.get(), "in_channel_layout", 
                        av_get_default_channel_layout(m_src_channels), 0);
        av_opt_set_int(m_swr_ctx.get(), "in_sample_rate", m_src_samplerate, 0);
        av_opt_set_sample_fmt(m_swr_ctx.get(), "in_sample_fmt", m_src_format, 0);

        av_opt_set_int(m_swr_ctx.get(), "out_channel_layout", 
                        av_get_default_channel_layout(m_dst_channels), 0);
        av_opt_set_int(m_swr_ctx.get(), "out_sample_rate", m_dst_samplerate, 0);
        av_opt_set_sample_fmt(m_swr_ctx.get(), "out_sample_fmt", m_dst_format, 0);

        if ((result = swr_init(m_swr_ctx.get())) < 0) {
            ALOGE("Failed to initialize the resampling context");
            goto end;
        }

        if ((result = m_audiofifo->initFiFO(m_dst_channels, m_dst_format)) < 0) {
            goto end;
        }

    end:
        return result;
    }

    int pushAudioData(const uint8_t **input_samples, const int frame_size) {
        int result;
        reallocFrame(frame_size);
        result = swr_convert(m_swr_ctx.get(), m_temp_buffer->data, m_temp_buffer->nb_samples,
            input_samples, frame_size);
        if (result < 0) {
            ALOGE("Error while swr_convert  %d < %d", result, frame_size);
            return -1;
        }

        if (m_audiofifo->pushAudioData(m_temp_buffer->data, result) < 0)
            return -1;

        return 0;
    }

    /**
    * Read data from Fifo.
    * @return       number of samples actually read, or negative AVERROR code
    *               on failure. The number of samples actually read will not
    *               be greater than nb_samples, and will only be less than
    *               nb_samples fifo_size is less than nb_samples.
    */
    int popAudioData(uint8_t **output_samples, const int nb_samples) {
        int result = m_audiofifo->popAudioData(output_samples, nb_samples);
        return result;
    }
    int getFifoSize() {
        return m_audiofifo->getFifoSize();
    }

    void refreshFifo() {
        return m_audiofifo->refreshFifo();
    }
private:
    void reallocFrame(int frame_size) {
        if (!m_temp_buffer) {
            m_temp_buffer.reset(av_frame_alloc(), AVFrame_DeleteFun);
        }
        if (m_temp_buffer && m_temp_buffer->nb_samples < frame_size) {
            av_frame_unref(m_temp_buffer.get());
            m_temp_buffer->format = m_dst_format;
            m_temp_buffer->nb_samples = av_rescale_rnd(swr_get_delay(m_swr_ctx.get(), m_src_samplerate) + frame_size,
                m_dst_samplerate, m_src_samplerate, AV_ROUND_UP);
            m_temp_buffer->sample_rate = m_dst_samplerate;
            m_temp_buffer->channel_layout = av_get_default_channel_layout(m_dst_channels);
            av_frame_get_buffer(m_temp_buffer.get(), 32);
        }
    }


private:
    std::unique_ptr<SwrContext, decltype(Swr_DeleteFun)> m_swr_ctx;
    std::unique_ptr<AudioFiFO> m_audiofifo;
    std::shared_ptr<AVFrame> m_temp_buffer;

    int32_t m_src_samplerate;
    int32_t m_src_channels;
    enum AVSampleFormat m_src_format;

    int32_t m_dst_samplerate;
    int32_t m_dst_channels;
    enum AVSampleFormat m_dst_format;
};





int main(int argc, char *argv) {
    FILE *fd = fopen(R"(D:\videoFile\music.pcm)", "rb");
    AudioResample ar;
    ar.setInputAudioParm(48000, 2, AV_SAMPLE_FMT_S16);
    ar.setOutputAudioParm(96000, 4, AV_SAMPLE_FMT_S32);
    ar.createEngine();
    AVFrame *frame = av_frame_alloc();
    frame->format = AV_SAMPLE_FMT_S16;
    frame->nb_samples = 480;
    frame->channel_layout = av_get_default_channel_layout(2);
    frame->sample_rate = 48000;
    av_frame_get_buffer(frame, 32);


    int out_samples = 5000;
    int perFrame_size = sizeof(int32_t) * 4;
    uint8_t *outbuffer = (uint8_t*)malloc(perFrame_size* out_samples);
    for (;;) {
        int ret = fread(frame->data[0], sizeof(int16_t) * 2, frame->nb_samples, fd);
        if (ret < frame->nb_samples)
            break;
        ret = ar.pushAudioData((const uint8_t**)frame->data, frame->nb_samples);

        ret = ar.popAudioData(&outbuffer, out_samples);

        static FILE *fd_out = fopen(R"(C:\Users\JIE\aaaa.pcm)", "wb");
        fwrite(outbuffer, perFrame_size, ret, fd_out);


    }


}

